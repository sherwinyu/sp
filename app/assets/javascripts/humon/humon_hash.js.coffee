Humon.Hash = Humon.List.extend
  isHash: true
  isList: false
  hasKeys: true

  # @param keyOrIndex the value to access
  # attempts to do a look up against _value
  # If the key is a number of a numeric string, look up by index
  # Otherwise, look up by childNode's nodeKey
  unknownProperty: (keyOrIndex) ->
    # If it's a string, look up by key
    if isNaN(keyOrIndex) && keyOrIndex.constructor == String
      @_value.findProperty('nodeKey', keyOrIndex)
    # If it's a number (or numeric string), look up by index
    else if !isNaN(keyOrIndex)
      @_value[keyOrIndex]
    else
      throw new Error "invalid key or index #{keyOrIndex}"

  toJson: ->
    ret = {}
    for node in @_value
      key = node.get('nodeKey')
      key ?= @_value.indexOf node
      ret[key] = HumonUtils.node2json node
    ret

Humon.Hash.reopenClass
  ##
  # @param json the json payload to convert into a HumonValue
  # @context a context object with keys:
  #   - node: the node that will be containing the nodeValue corresponding to `json`
  # @return Humon.Hash
  #
  # Returns a Humon.Hash whose child key-value pairs are set to the corresponding
  # key-values pairs in `json`, generated by calling `Utils.json2node` on the json val.
  # Each of the children are HumonNodes.
  # Each HumonNode has `nodeParent` set to `context.node`
  # @param context
  #  context.node: the Humon.Node object that will wrap this Humon.Value
  j2hnv: (json, context)->
    if context.metatemplate?
      Em.assert("context.metatemplate specified but doesn't match this class!", context.metatemplate.name == @_name())
      if not @matchesJson json
        json = @_coerceToValidJsonInput json
    json = @_initJsonDefaults (json)

    childNodes = []
    for own key, childVal of json
      childNode = HumonUtils.json2node(childVal, nodeParent: context.node)
      childNode.set 'nodeKey', key
      childNodes.pushObject childNode
    Humon.Hash.create _value: childNodes, node: context.node

  # @param json the json payload to test
  # returns true if this is a POJO
  matchesJson: (json) ->
    json? and (typeof json is 'object') and !(json instanceof Array) and json.constructor == Object

  ##
  # @override
  _coerceToValidJsonInput: (json) ->
    @_super()

  ##
  # @override
  _initJsonDefaults: (json) ->
    json ||= {}

